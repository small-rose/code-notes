---
layout: default
title: 策略模式
nav_order: 90
parent: 行为型模式
grand_parent: 设计模式（Design Pattern）
---

# 定义

{: .new-title}
> 策略模式
> 
> 策略是一种`行为设计模式`，它能让你定义一系列算法，并将每种算法分别放入独立的类中，以使算法的对象能够相互替换。

# 结构

![](https://cdn.jsdelivr.net/gh/guosonglu/images@master/blog-img/20221219223306.png)

- `上下文（Context）`维护指向具体策略的引用，且仅通过策略接口与该对象进行交流。
- `策略（Strategy）`接口是所有具体策略的通用接口，它声明了一个上下文用于执行策略的方法。
- `具体策略（Concrete Strategies）`实现了上下文所用算法的各种不同变体。
- `客户端（Client）`会创建一个特定策略对象并将其传递给上下文。上下文则会提供一个设置器以便客户端在运行时替换相关联的策略。

# 使用场景

- 将不同的算法封装进不同的类中                  

# 优缺点

{: .note-title}
> 优点
> 
> 可以将算法的实现和使用算法的代码隔离开来。
> 
> `开闭原则`：无需对上下文进行修改就能够引入新的策略。
> 
> `简化了单元测试`：因为每个算法都有自己的类，可以通过自己的接口单独测试。

{: .warning-title}
> 弊端
> 
> 如果你的算法极少发生改变，那么没有任何理由引入新的类和接口。使用该模式只会让程序过于复杂。
> 
> 客户端必须知晓策略间的不同,它需要选择合适的策略。
> 
> 可以考虑使用`Lambda`替代策略模式

# 模式比较

## 策略模式和简单工厂模式

{: .note-title}
> 策略模式和简单工厂相同点
> 
> 结构上策略模式中的`策略（Strategy）`和`具体策略（Concrete Strategies）`与简单工厂模式中的`产品（Product）`和`具体产品（Concrete Products）`是一样的

{: .note-title}
> 策略模式和简单工厂不同点
> 
> `简单工厂模式`侧重的是对象的创建。
> `策略模式`侧重的是面向高层`策略类`中算法接口的调用。换句话说，`上下文类`中并不关心`策略对象`的创建方式，可以通过构造依赖注入，也可以通过`简单工厂`进行依赖注入


# 模式结合使用

## 策略模式和简单工厂模式结合使用

`上下文（Context）`类中的抽象`策略（Strategy）`对象可以使用简单工厂进行依赖注入。

## 策略模式和装饰模式结合使用

可以对`策略（Strategy）`进行`装饰`
