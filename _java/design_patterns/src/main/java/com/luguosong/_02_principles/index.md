---
layout: default
title: 软件设计原则
nav_order: 2
parent: 设计模式（Design Pattern）
---


# 优秀设计特征

## 复用

`代码复用`是减少开发成本时最常用的方式之一。

## 扩展性

`变化`是程序员生命中唯一不变的事情。

# 设计原则

## 封装变化的内容

>找到程序中的变化内容并将其与不变的内容区分开。

该原则的主要目的是将变更造成的影响最小化。

- 方法层面的封装
- 类层面的封装

## 面向接口进行开发，而不是面向实现

{: .note}
面向接口进行开发，而不是面向实现；依赖于抽象类型，而不是具体类。

上游系统面向`接口`而非`实现`编程，不依赖不稳定的实现细节，这样当实现发生变化的时候，上游系统的代码基本上不需要做改动，以此来`降低耦合性`，`提高扩展性`。

接口的定义只表明做什么，而不是怎么做。

如果在我们的业务场景中，某个功能只有一种实现方式，未来也不可能被其他实现方式替换，那我们就没有必要为其设计接口，也没有必要基于接口编程，直接使用实现类就可以了。

## 组合优于继承

继承层次过深、继承关系过于复杂会影响到代码的可读性和可维护性。

利用组合能解决层次过深、过复杂的继承关系影响代码可维护性的问题。

如果类之间的继承结构稳定，层次比较浅，关系不复杂，我们就可以大胆地使用继承。反之，我们就尽量使用组合来替代继承。

# SOLID 原则

这五条原则是在罗伯特·马丁的著作[《敏捷软件开发：原则、模式与实践》](https://book.douban.com/subject/5348122/)中首次提出的

## 单一职责原则（Single Responsibility Principle）

{: .new}
修改一个类的原因只能有一个。


尽量让每个类只负责软件中的一个功能，并且该职责被完整地封装(隐藏)在一个类中。

目的是`减少复杂度`。

## 开闭原则

软件实体应该对拓展开放，对修改关闭。

软件实体应尽量在 `不修改原有代码`的情况下进行 `拓展`。

## 里氏代换原则

所有引用基类的地方必须能透明地使用其子类的对象。

父类对象可以用子类对象替换，子类对象不能用父类对象替换。

`里氏代换原则`是实现 `开闭原则`的重要方式之一。程序中尽量使用父类类型来对对象进行定义，而在运行时再确定其子类类型，
用子类对象来替代父类对象。

## 依赖倒转原则

高层模块不应该依赖低层模块，它们都应该依赖抽象。抽象不应该依赖于细节，细节应该依赖于抽象。

针对接口编程，不要针对实现编程。换句话说，就是尽量不要使用具体的实现类，而是使用它对应的接口或者所继承的抽象类。

面向接口编程时，具体类需要通过依赖注入（Dependence Injection）的方式注入到对象中，
一般有以下三种注入方式：

- 构造注入：通过构造函数传入具体类的对象
- 设值注入：通过Setter方法传入具体类的对象
- 接口注入：方法在定义时使用的是抽象类型，运行时再传入具体类的对象

## 接口隔离原则

客户端不应该依赖那些它不需要的接口

将大接口中的方法根据职责不同放在不同小接口中，以确保每个接口使用起来都较为方便。

同时接口的粒度也不能太小，否则会导致系统接口泛滥，不利于维护。

## 合成复用原则

优先使用对象组合，而不是通过继承来达到复用的目的。

继承破坏了基类的封装性，将基类的实现细节暴露给了子类。

相比于继承，组合可以使系统更加灵活，降低类与类之间的耦合度。

## 迪米特法则

每一个软件单位对其它单位都只是最少的知识，而且局限于那些与本单位密切相关的软件单位。

不要和 `陌生人`说话，只与你的直接 `朋友`通讯。在迪米特法则中，对于一个对象，其朋友包括以下几类：

- 当前对象本身（this）
- 以参数形式传入到当前对象方法中的对象。
- 当前对象的成员对象
- 如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友
- 当前对象所创建的对象

# 小结

一般情况下 `开闭原则`，`里氏代换原则`和 `依赖倒置原则`会同时出现，其中：

- 开闭原则是目的
- 里氏代换原则是基础
- 依赖导致原则是手段
